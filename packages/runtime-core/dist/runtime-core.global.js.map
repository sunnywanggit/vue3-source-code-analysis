{"version":3,"file":"runtime-core.global.js","sources":["../../shared/src/index.ts","../../reactivity/src/effect.ts","../../reactivity/src/baseHandlers.ts","../../reactivity/src/reactive.ts","../../reactivity/src/ref.ts","../src/vnode.ts","../src/apiCreateApp.ts","../src/component.ts","../src/renderer.ts","../src/h.ts"],"sourcesContent":["export const isObject = (val) => typeof val == 'object' && val !== null;\nexport const isNumber = (val) => typeof val == 'number';\nexport const isFunction = (val) => typeof val == 'function'\nexport const isString = (val) => typeof val == 'string'\nexport const isBoolean = (val) =>  typeof val == 'boolean';\nexport const isArray =  Array.isArray;\nexport const extend = Object.assign;\n\n\n// 判断属性是不是原型属性 \nexport const hasOwn = (target,key) => Object.prototype.hasOwnProperty.call(target,key);\nexport const hasChanged = (oldValue,value) => oldValue !== value\n\nexport const isInteger = (key) => parseInt(key) + '' === key; // '3'  arr.xxx\n\n\n\nexport const enum ShapeFlags {\n    ELEMENT = 1, // 1元素\n    FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件 2 \n    STATEFUL_COMPONENT = 1 << 2, // 带状态的组件 4 \n    TEXT_CHILDREN = 1 << 3, // 内容是文本还 8 \n    ARRAY_CHILDREN = 1 << 4, // 内容是数组孩子 16\n    SLOTS_CHILDREN = 1 << 5,\n    TELEPORT = 1 << 6,\n    SUSPENSE = 1 << 7,\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n    COMPONENT_KEPT_ALIVE = 1 << 9,\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n  }\n  \n\n  // +=   LET XXX = A+B\n  // |=   LET XXX = A | B","import { isArray, isInteger } from \"@vue/shared/src\";\n\nexport function effect(fn, options: any = {}) { // fn 不具备数据变化了就更新视图\n    let effect = createReactiveEffect(fn, options); // 把fn包装成一个响应式的函数\n    if (!options.lazy) {\n        effect();\n    }\n    return effect\n}\nlet uid = 0;\nlet activeEffect; // 此模块内唯一的一个变量\nfunction createReactiveEffect(fn, options) {\n    const effect = function () {\n        // 我需要将effect暴露到外层\n        activeEffect = effect; // Dep.target = watcher\n\n        fn(); // 当我执行用户传入的函数时 会执行get方法\n        activeEffect = null;\n\n    }\n    effect.id = uid++; // 每个effect都有一个唯一的标识 （watcher）\n    effect._isEffect = true; // 用于标识这个函数是一个effect函数\n    effect.raw = fn; // 把用户传入的函数保存到当前的effect上\n    effect.deps = []; // 后续用来存放此effect对于哪些属性\n    effect.options = options;\n    return effect;\n}\n// obj   name   => \n/**\nweakMap = {\n    object:Map({\n        name:new Set(effect,effect)\n    })\n}\n */\nconst targetMap = new WeakMap(); // weakMap 的key只能是对象\nexport function track(target, type, key) { // {obj:name=> [effect,effect]}  weakMap : (map){key: new Set()}\n    if (!activeEffect) { // 说明取值操作是在effect之外操作的 \n        return\n    } // 直接跳过依赖收集\n    let depsMap = targetMap.get(target); // 先尝试看一下这个对象中是否存过属性\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map)); // {obj:map({key:set(effect,effect)})}\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set));\n    }\n    if (!dep.has(activeEffect)) { // 同一个属性 不会添加重复的effect\n        dep.add(activeEffect)\n    }\n    // 制作一个依赖收集的关联列表\n}\nexport function trigger(target, key, value, type) { // ? 会引起 没用到的属性修改也会更新 \n    const depsMap = targetMap.get(target); // 先看一下有没有收集过依赖\n\n    if (!depsMap) return; // 如果没有收集过 直接跳过\n\n\n    // 为了实现批处理 我们把所有的effect放到一个set中 ，做一下去重 \n    const effectsQueue = new Set();\n    const add = (effectsToAdd) => {\n        if (effectsToAdd) effectsToAdd.forEach(effect=>effectsQueue.add(effect));\n    }\n    // 如果修改的是数组 并且改的是长度 要做一些处理  \n    if (isArray(target) && key == 'length') {\n        // value; // 是数组长度   depsMap 存放的key 可能是索引 如果索引大于数组长度 修奥触发更新\n        depsMap.forEach((dep, depKey) => { \n            // [1,2,3]  arr[2]  arr.length = 1  3=> undefined\n            // [1,2,3]  arr[2]  arr.length = 100  3=> 3\n            if (depKey == 'length' || value < depKey) {\n                add(dep)\n            }\n        })\n    } else {\n        if (type == 'add') { // 新增逻辑 需要触发更新 触发length的更新 针对的是数组 \n            if (isArray(target) && isInteger(key)) {\n                add(depsMap.get('length'))\n            }else{ // 对象新增逻辑, 对象新增逻辑也要触发对应的更新\n                add(depsMap.get(key))\n            }\n        } else {\n            const effects = depsMap.get(key); // 找到此属性对应的effect列表 ，直接执行即可\n            add(effects)\n        }\n    }\n    effectsQueue.forEach((effect:any)=>{\n        if(effect.options.scheduler){\n            effect.options.scheduler(effect)\n        }else{\n            effect()\n        }\n    });\n    \n}","// 我们期望 实现get和set\n\nimport { extend, hasChanged, hasOwn, isArray, isInteger, isObject } from \"@vue/shared/src\";\nimport { track, trigger } from \"./effect\";\nimport { reactive, readonly } from \"./reactive\";\n\n// 借助函数科里化的思想，传不同的值返回不同的函数\nconst get = createGetter();\nconst readonlyGet = createGetter(true); // 仅读的get\nconst shallowGet = createGetter(false, true); // 非仅读但是是浅的\nconst shallowReadonlyGet = createGetter(true, true); // 仅读是浅的\n\nconst set = createSetter();\n\n// 响应式原理的核心就在这个依赖收集\nconst readonlySet = {\n    set(target, key) {\n        console.warn(`cannot set on ${key}, readonly!!!`)\n    }\n}\nfunction createSetter() {\n    return function set(target, key, value, receiver) { // value就是设置的值 ，其他一样\n        let oldValue = target[key]; // 原对象来缓存老值，没有通过代理对象 不会触发get\n\n        // 如果是新增也要触发更新\n        let hadKey = isArray(target) && isInteger(key) ? key < target.length : hasOwn(target,key);\n\n\n        // 触发视图更新， 去做处理\n\n        let res = Reflect.set(target, key, value, receiver); // target[key] = value\n\n        if(!hadKey){ // 新增逻辑\n            trigger(target, key, value,'add');\n        }else if (hasChanged(oldValue, value)) {\n            // 需要触发更新逻辑  obj name\n            trigger(target, key, value,'set'); // 触发这个对象上的属性 让他更新\n        }\n        return res;\n    }\n}\n\n\nfunction createGetter(isReadonly = false, shallow = false) {\n    // 取值的时候第一个是目标 ， 第二个是属性是谁， 第三个就是代理对象是谁\n    return function get(target, key, receiver) { // new Proxy({},{get(){}})\n        // 依赖收集  proxy 和 reflect 一般情况下会联合使用\n\n        let res = Reflect.get(target, key, receiver) //  这二者是等价的 target[key]\n        // 之所以使用 reflect 是因为我们在使用 reflect 的时候会给我们一个返回值，告诉我们处理成功还是失败\n\n        if (isReadonly) { // 如果对象是一个仅读的属性，那就以意味着这个对象不可能被更改，不可能更新视图，不需要增添依赖收集\n            return res;\n        }\n        if (shallow) {\n            return res; // 如果是浅的说明不需要递归代理了\n        }\n        if (isObject(res)) { // 如果是对象 就递归代理，但是不是一开始就代理，是在用到这个对象的时候才进行代理的\n            // target[key];  懒代理，当取值的时候才去进行代理,而不是一上来全部递归，性能提升了很多\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res;\n    }\n}\nexport const mutableHandlers = { // 核心进行劫持的方法  处理get和set的逻辑\n    get,\n    set\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    set\n}\nexport const readonlyHandlers = extend({\n    get: readonlyGet,\n}, readonlySet)\nexport const shallowReadonlyHandlers = extend({\n    get: shallowReadonlyGet,\n}, readonlySet)\n","// 根据不同的参数实现不同的功能\nimport { isObject } from \"@vue/shared\"\nimport { mutableHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers } from \"./baseHandlers\"\n\n// 1.proxy 是一个es6的api，兼容性差，我们先来看一下这个 api 是怎么使用的\n// http://js.jirengu.com/juyim/3/edit?js,console,output\n\n// 给每个对象增加一个缓存区，防止对象被重复代理\n// 之所以使用 WeakMap,它有一个能力叫弱“引用”\n// map\"强引用“,它的key是可以用对象的,所以不会进入垃圾回收机制，会导致内存泄露\n// weakMap中的key只能是对象，如果引用的key 被置为 null weakmap 会自行自动回收\n// 用了 webmap 我们就不需要去手动的管理这些内存问题\nconst reactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\n\n// 函数科里化：这四个 api 都是使用 proxy 包装一下，区别只是是否仅读，是否浅层代理\nexport function reactive(target:object){ // mutableHandlers\n    return createReactiveObject(target,mutableHandlers,reactiveMap);\n}\nexport function shallowReactive(target:object){ // shallowReactiveHandlers\n    return createReactiveObject(target,shallowReactiveHandlers,shallowReactiveMap)\n}\nexport function readonly(target:object){ // readonlyHandlers\n    return createReactiveObject(target,readonlyHandlers,readonlyMap)\n}\nexport function shallowReadonly(target:object){ // shallowReadonlyHandlers\n    return createReactiveObject(target,shallowReadonlyHandlers,shallowReadonlyMap)\n}\n\n\n/**\n * @description 创建响应式对象 以上四个方法最终用的都是这一个方法，这个方法会根据参数的不同 来进行不同的处理,我们用这个方法来抹平差异\n * @param {Object} target 需要被代理的目标对象\n * @param {Function} baseHandlers 针对每种方式对应的不同处理函数\n * @param proxyMap\n */\nexport function createReactiveObject(target,baseHandlers,proxyMap) {\n    // 和 vue2 一样要看一下目标是不是对象,不是对象直接返回，无需代理\n    if(!isObject(target)){\n        return target\n    }\n    // 创建代理对象返回， let obj = {} reactive(obj)   readonly(obj) 做缓存 不要重复代理\n    // const proxyMap  = isReadonly ? readonlyMap : reactiveMap\n    const existsProxy = proxyMap.get(target);\n    // 如果已经代理过了，直接返回\n    if(existsProxy){\n        return existsProxy\n    }\n    // 创建代理对象\n    const proxy = new Proxy(target,baseHandlers);\n    proxyMap.set(target,proxy); // 缓存起来，避免重复代理 reactive(reactive({}))\n    return proxy\n}\n","import { hasChanged, isArray, isObject } from \"@vue/shared/src\";\nimport { track, trigger } from \"./effect\";\nimport { reactive } from \"./reactive\";\n\n\nexport function ref(value) {\n    return createRef(value);\n}\n\nexport function shallowRef(value) {\n    return createRef(value, true);\n}\nconst convert = val => isObject(val) ? reactive(val) : val;\n\nclass RefImpl {\n    private _value;\n    constructor(private rawValue, public isShallow) {\n        this._value = isShallow ? rawValue : convert(rawValue) // this._value 就是一个私有属性 \n    }\n    // 这两个方法 会被转化成defineProperty\n    get value() {\n        track(this, 'get', 'value')\n        return this._value;\n    }\n    set value(newValue) {\n        if (hasChanged(newValue, this.rawValue)) {\n            this.rawValue = newValue; // 说明属性变化 需要更新\n            this._value = this.isShallow ? newValue : convert(newValue)\n            trigger(this, 'value', newValue, 'set');\n        }\n\n    }\n}\nfunction createRef(value, isShallow = false) {\n    return new RefImpl(value, isShallow)\n\n}\nclass ObjectRefImpl{ // vue2 proxy 是一样的\n    constructor(public target,public key){}\n    get value(){\n        return this.target[this.key];\n    }\n    set value(newValue){\n        this.target[this.key] = newValue;\n    }\n}\n\n// promisefy\n// promisifyAll\nexport function toRefs(object){\n    // 对象的浅拷贝 \n    const ret = isArray(object)? new Array(object.length) : {};\n    for(let key in object){\n        ret[key] = toRef(object,key);\n    }\n    return ret;\n}\n\n\nexport function toRef(target,key){ // 就是取出某个属性变成ref\n    return new ObjectRefImpl(target,key)\n}\n\n\n// 模板渲染的时候 会去判断是不是ref 如果是ref  就直接.value","// h 最终也会调用这个方法  h('div',{},'a','b')  h(组件)  h(函数)  。。。\n\nimport { isArray, isObject, isString, ShapeFlags } from \"@vue/shared/src\";\n\nexport function createVnode(type, props, children = null) { // []\n    const shapeFlag =\n        isString(type) ? ShapeFlags.ELEMENT :\n            isObject(type) ? ShapeFlags.STATEFUL_COMPONENT\n                : 0;\n\n    const vnode = {\n        __v_isVnode:true,\n        type,\n        props,\n        children,\n        el:null, // 对应的真实节点,\n        key:props && props.key, // diff 算法需要key\n        shapeFlag // 描述虚拟节点是什么类型的\n    }\n\n    normalizeChildren(vnode,children)\n    // 我要看这个标签 他和他的儿子怎么做\n    // diff算法的时候 需要判断两方都有儿子  ， 一方儿子是什么类型的...\n\n    return vnode;\n}\n\nfunction normalizeChildren(vnode,children){\n    if(children == null){\n\n    }else if(isArray(children)){\n        vnode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN;\n    } else{\n        vnode.shapeFlag |= ShapeFlags.TEXT_CHILDREN;\n    }\n}\n\n// isElementAndArrayChildren\n\n// h('div',{},['hello','wolred])  此虚拟节点的shapeFlag 是17 表示 他是一个元素 有多个儿子\n// shapeFlag = 1 | 16\n\n\n// 17 是不是元素  17 & 1 大于0是元素\n// 17 & 16 如果是大于0 就是数组孩子\n","import { createVnode } from \"./vnode\";\n\nexport function createAppAPI(render){\n    return (rootComponent,rootProps)=>{ // 创建应用你需要给我传入组件和属性\n        let app = {\n            _component:rootComponent,\n            _rootProps:rootProps,\n            _container:null,\n            use(){\n\n            },\n            mixin(){\n\n            },\n            component(){\n\n            },\n            mount(container){ // 容器\n                // 创建一个虚拟节点\n                const vnode = createVnode(rootComponent,rootProps); // h方法\n    \n                // 将虚拟节点 转换成真实节点，插入到container中\n    \n                render(vnode,container);\n\n                app._container = container;\n                \n            }\n        }\n        return app\n    }\n}","import { hasOwn, isFunction, isObject, ShapeFlags } from \"@vue/shared\";\n\nexport function createComponentInstance(vnode){\n    const instance = {\n        vnode, // 组件的虚拟节点\n        data:{},\n        attrs:{}, // 去掉用户使用的props之后的结果 \n        props:{xxx:1}, // 用户写的props\n        slots:{},\n        render:null,\n        setupState:{},\n        subTree:null , // 组件渲染的虚拟节点的结果  $vnode _vnode\n        isMounted:false, // 组件是否挂载过\n        bc:null,\n        m:null,\n        ctx:{},\n        proxy:{},\n        update:null\n    }\n    // vue2 中取 props,data？ 在哪里取出来的 this._data this._props\n    instance.ctx = {_:instance}\n\n    // new Proxy\n    return instance;\n}\nconst isStatefulComponent = (vnode)=>{\n    return vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n}\n// vue2 无状态组件 就是没有data，只有属性和外界传过来的数据 \n\nfunction createContext(instance){\n    return {\n        attrs:instance.attrs,// 用户传递的所有属性 ，不包含props\n        slots: instance.slots, // 组件的插槽\n        emit: ()=>{},// 用于发射最新的结果的 $emit\n        expose:()=>{} // 如果用户使用了ref属性 放到了组件上，他默认拿到的是组件的实例，但是如果定义了expose，那么就拿到的是expose，不在是组件实例\n    }\n}\nfunction finishComponentSetup(instance){\n    const Component = instance.vnode.type;\n    if(!instance.render){\n        if(!Component.render && Component.template){ // vue2 中模板编译原理就是把template变成render函数\n            // 把模板编译成render函数  -> compiler\n        }\n        instance.render = Component.render; // 组件的render挂载到实力上\n\n        // render函数 就是用户写的render， 数据可以在 instance.proxy上取\n    }\n}\nfunction handleSetupResult(instance,setupResult){\n    if(isFunction(setupResult)){\n        instance.render = setupResult\n    }else if(isObject(setupResult)){\n        instance.setupState = setupResult\n    }\n    finishComponentSetup(instance);\n}\n\nfunction setupStatefulComponent(instance){\n     const Component = instance.vnode.type // 用户定义的对象，组件本身\n     instance.proxy = new Proxy(instance.ctx,{\n         get({_:instance},key){\n            const {setupState,props,data} = instance;\n            if(hasOwn(setupState,key)){\n                return setupState[key]\n            }else if(hasOwn(data,key)){\n                return data[key]\n            }else if(hasOwn(props,key)){\n                return props[key]\n            }\n         },\n         set({_:instance},key,value){\n            const {setupState,props,data} = instance;\n            if(hasOwn(setupState,key)){\n                setupState[key] = value\n            }else if(hasOwn(data,key)){\n                 data[key] = value\n            }else if(hasOwn(props,key)){\n                 props[key] = value\n            }\n            return true;\n         }\n     })\n     let {setup } = Component;\n     if(setup){\n        let ctx = createContext(instance);\n        const setupResult = setup(instance.props,ctx);\n        handleSetupResult(instance,setupResult);\n     }else{\n        finishComponentSetup(instance);\n     }\n\n}\nexport function setupComponent(instance){\n    const {props,children} = instance.vnode;\n    // initProps()\n    // initSlot()\n    const isStateful =  isStatefulComponent(instance.vnode) \n    const setupResult = isStateful ? setupStatefulComponent(instance):undefined; // 取setup的返回值\n   \n\n}\n","import { effect } from \"@vue/reactivity\";\nimport { ShapeFlags } from \"@vue/shared\";\nimport { createAppAPI } from \"./apiCreateApp\"\nimport { createComponentInstance, setupComponent } from \"./component\";\nexport function createRenderer(rendererOptions) { // 不同的平台 rendererOptions 渲染属性是不同的\n\n    const {\n        insert: hostInsert,\n        remove: hostRemove,\n        patchProp: hostPatchProp,\n        createElement: hostCreateElement,\n        createText: hostCreateText,\n        setText: hostSetText,\n        setElementText: hostSetElementText,\n    } = rendererOptions\n\n    const mountChildren = (children, container) => {\n        for (let i = 0; i < children.length; i++) {\n            patch(null, children[i], container)\n        }\n    }\n    const mountElement = (n2, container) => {\n        // 递归渲染虚拟节点\n        const { props, type, children, shapeFlag } = n2;\n        let el = n2.el = hostCreateElement(type)\n        if (props) {\n            for (let key in props) {\n                hostPatchProp(el, key, null, props[key]);\n            }\n        }\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n            hostSetElementText(el, children);\n        } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n            mountChildren(children, el);\n        }\n        hostInsert(el, container);\n    }\n\n\n    const processElement = (n1, n2, container) => {\n        if (n1 == null) {\n            // 元素的初始化\n            mountElement(n2, container);\n        } else {\n            // 元素的diff\n        }\n    }\n\n\n    const patch = (n1, n2, container) => { // n2 如果为null 会走销毁逻辑\n\n\n        // 渲染逻辑 diff算法\n\n        const { shapeFlag } = n2;\n\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n            // n2 是什么类型的 如果是一个元素的虚拟节点 -》 创建一个元素的真实节点 插入到容器中\n            processElement(n1, n2, container);\n\n        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n            // 初始化的时候 n2 是一个组件的虚拟节点\n            processComponent(n1, n2, container);\n\n        }\n    }\n    // 和 vue2 组件渲染一致 -》 组件的虚拟节点-》 创造组件实例-》 调用组件的render方法 -》 拿到组件的返回的虚拟节点 -》 创建真是节点 \n    // vue2 组件每个组件都有一个watcher， 如果数据更新 重新执行watcher， 依赖收集\n\n\n    const setupRenderEffect = (instance, container) => {\n        instance.update = effect(() => { // effect执行后会返回一个响应式的effect\n            if (!instance.isMounted) {\n                // 初渲染逻辑, 会进行依赖收集 用到的属性 会将组件的effect收集起来\n\n                let subTree = instance.subTree = instance.render.call(instance.proxy, instance.proxy)\n\n                patch(null, subTree, container);\n\n                instance.isMounted = true;\n            } else {\n                // 数据变化了 会执行此逻辑 diff算法\n                let prevSubTree = instance.subTree;\n                let nextSubTree =  instance.render.call(instance.proxy, instance.proxy);\n\n                // patch(prevSubTree, nextSubTree, container);\n\n                // 下周四 周六 手写Vuex4.0\n                // 下周四 周六 手写Vue-router4.0\n                // \n            }\n        },{\n            scheduler(effect){ // 多次更新 可以批量更新  effect.uid\n                // queueWatcher\n                console.log(effect,'--------------');\n            }\n        })\n    }\n\n    const mountComponent = (n2, container) => {\n        // 1.组件如何挂载？  new vnode.componentOptions.Ctor => vnode.componentInstance\n        // 创建一个组件的实例\n        const instance = createComponentInstance(n2); // 组件创建流程\n\n        setupComponent(instance); // 将自己的数据 填充到instance上\n\n        // instance.render(instance.proxy ) => h()  => 虚拟节点 => 真实节点\n        setupRenderEffect(instance, container); // 添加渲染effect\n    }\n    const processComponent = (n1, n2, container) => {\n        if (n1 == null) {\n            // 初始化\n            mountComponent(n2, container);\n        } else {\n            // 组件更新 updateComponent  组件的diff\n        }\n    }\n\n\n    const render = (vnode, container) => { // 初次渲染流程\n        // 根据虚拟节点 创建真实节点 插入到容器中\n        patch(null, vnode, container)\n    }\n\n    return { // 把这个api单独的抽离成了一个文件，并把render函数传入\n        createApp: createAppAPI(render)\n    }\n}","import { isArray, isObject } from \"@vue/shared\";\nimport { createVnode } from \"./vnode\";\n\nexport function h(type, propsOrChildren, children) {\n    //  2 3 多个\n    let l = arguments.length;\n    if (l == 2) {\n        // 1.类型 + 属性 \n        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n            return createVnode(type, propsOrChildren)\n        } else {\n            // 第二个参数是一个数组 \n            return createVnode(type, null, propsOrChildren)\n        }\n    } else {\n        if (l == 3) {\n            return createVnode(type, propsOrChildren, children)\n        } else if (l > 3) {\n            return createVnode(type, propsOrChildren, Array.from(arguments).slice(2))\n        }\n    }\n\n}"],"names":[],"mappings":"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"}