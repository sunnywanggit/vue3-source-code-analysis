{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts"],"sourcesContent":["export const isObject = (val) => typeof val == 'object' && val !== null;\nexport const isNumber = (val) => typeof val == 'number';\nexport const isFunction = (val) => typeof val == 'function'\nexport const isString = (val) => typeof val == 'string'\nexport const isBoolean = (val) =>  typeof val == 'boolean';\nexport const isArray =  Array.isArray;\nexport const extend = Object.assign;\n\n\n// 判断属性是不是原型属性 \nexport const hasOwn = (target,key) => Object.prototype.hasOwnProperty.call(target,key);\nexport const hasChanged = (oldValue,value) => oldValue !== value\n\nexport const isInteger = (key) => parseInt(key) + '' === key; // '3'  arr.xxx\n\n\n\nexport const enum ShapeFlags {\n    ELEMENT = 1, // 1元素\n    FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件 2 \n    STATEFUL_COMPONENT = 1 << 2, // 带状态的组件 4 \n    TEXT_CHILDREN = 1 << 3, // 内容是文本还 8 \n    ARRAY_CHILDREN = 1 << 4, // 内容是数组孩子 16\n    SLOTS_CHILDREN = 1 << 5,\n    TELEPORT = 1 << 6,\n    SUSPENSE = 1 << 7,\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n    COMPONENT_KEPT_ALIVE = 1 << 9,\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n  }\n  \n\n  // +=   LET XXX = A+B\n  // |=   LET XXX = A | B","import { isArray, isInteger } from \"@vue/shared/src\";\n\nexport function effect(fn, options: any = {}) { // fn 不具备数据变化了就更新视图\n    let effect = createReactiveEffect(fn, options); // 把fn包装成一个响应式的函数\n    if (!options.lazy) {\n        effect();\n    }\n    return effect\n}\nlet uid = 0;\nlet activeEffect; // 此模块内唯一的一个变量\nfunction createReactiveEffect(fn, options) {\n    const effect = function () {\n        // 我需要将effect暴露到外层\n        activeEffect = effect; // Dep.target = watcher\n\n        fn(); // 当我执行用户传入的函数时 会执行get方法\n        activeEffect = null;\n\n    }\n    effect.id = uid++; // 每个effect都有一个唯一的标识 （watcher）\n    effect._isEffect = true; // 用于标识这个函数是一个effect函数\n    effect.raw = fn; // 把用户传入的函数保存到当前的effect上\n    effect.deps = []; // 后续用来存放此effect对于哪些属性\n    effect.options = options;\n    return effect;\n}\n// obj   name   => \n/**\nweakMap = {\n    object:Map({\n        name:new Set(effect,effect)\n    })\n}\n */\nconst targetMap = new WeakMap(); // weakMap 的key只能是对象\nexport function track(target, type, key) { // {obj:name=> [effect,effect]}  weakMap : (map){key: new Set()}\n    if (!activeEffect) { // 说明取值操作是在effect之外操作的 \n        return\n    } // 直接跳过依赖收集\n    let depsMap = targetMap.get(target); // 先尝试看一下这个对象中是否存过属性\n    if (!depsMap) {\n        targetMap.set(target, (depsMap = new Map)); // {obj:map({key:set(effect,effect)})}\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n        depsMap.set(key, (dep = new Set));\n    }\n    if (!dep.has(activeEffect)) { // 同一个属性 不会添加重复的effect\n        dep.add(activeEffect)\n    }\n    // 制作一个依赖收集的关联列表\n}\nexport function trigger(target, key, value, type) { // ? 会引起 没用到的属性修改也会更新 \n    const depsMap = targetMap.get(target); // 先看一下有没有收集过依赖\n\n    if (!depsMap) return; // 如果没有收集过 直接跳过\n\n\n    // 为了实现批处理 我们把所有的effect放到一个set中 ，做一下去重 \n    const effectsQueue = new Set();\n    const add = (effectsToAdd) => {\n        if (effectsToAdd) effectsToAdd.forEach(effect=>effectsQueue.add(effect));\n    }\n    // 如果修改的是数组 并且改的是长度 要做一些处理  \n    if (isArray(target) && key == 'length') {\n        // value; // 是数组长度   depsMap 存放的key 可能是索引 如果索引大于数组长度 修奥触发更新\n        depsMap.forEach((dep, depKey) => { \n            // [1,2,3]  arr[2]  arr.length = 1  3=> undefined\n            // [1,2,3]  arr[2]  arr.length = 100  3=> 3\n            if (depKey == 'length' || value < depKey) {\n                add(dep)\n            }\n        })\n    } else {\n        if (type == 'add') { // 新增逻辑 需要触发更新 触发length的更新 针对的是数组 \n            if (isArray(target) && isInteger(key)) {\n                add(depsMap.get('length'))\n            }else{ // 对象新增逻辑, 对象新增逻辑也要触发对应的更新\n                add(depsMap.get(key))\n            }\n        } else {\n            const effects = depsMap.get(key); // 找到此属性对应的effect列表 ，直接执行即可\n            add(effects)\n        }\n    }\n    effectsQueue.forEach((effect:any)=>{\n        if(effect.options.scheduler){\n            effect.options.scheduler(effect)\n        }else{\n            effect()\n        }\n    });\n    \n}","// 我们期望 实现get和set\n\nimport { extend, hasChanged, hasOwn, isArray, isInteger, isObject } from \"@vue/shared/src\";\nimport { track, trigger } from \"./effect\";\nimport { reactive, readonly } from \"./reactive\";\n\n// 借助函数科里化的思想，传不同的值返回不同的函数\nconst get = createGetter();\nconst readonlyGet = createGetter(true); // 仅读的get\nconst shallowGet = createGetter(false, true); // 非仅读但是是浅的\nconst shallowReadonlyGet = createGetter(true, true); // 仅读是浅的\n\nconst set = createSetter();\n\n// 响应式原理的核心就在这个依赖收集\nconst readonlySet = {\n    set(target, key) {\n        console.warn(`cannot set on ${key}, readonly!!!`)\n    }\n}\nfunction createSetter() {\n    return function set(target, key, value, receiver) { // value就是设置的值 ，其他一样\n        let oldValue = target[key]; // 原对象来缓存老值，没有通过代理对象 不会触发get\n\n        // 如果是新增也要触发更新\n        let hadKey = isArray(target) && isInteger(key) ? key < target.length : hasOwn(target,key);\n\n\n        // 触发视图更新， 去做处理\n\n        let res = Reflect.set(target, key, value, receiver); // target[key] = value\n\n        if(!hadKey){ // 新增逻辑\n            trigger(target, key, value,'add');\n        }else if (hasChanged(oldValue, value)) {\n            // 需要触发更新逻辑  obj name\n            trigger(target, key, value,'set'); // 触发这个对象上的属性 让他更新\n        }\n        return res;\n    }\n}\n\n\nfunction createGetter(isReadonly = false, shallow = false) {\n    // 取值的时候第一个是目标 ， 第二个是属性是谁， 第三个就是代理对象是谁\n    return function get(target, key, receiver) { // new Proxy({},{get(){}})\n        // 依赖收集  proxy 和 reflect 一般情况下会联合使用\n\n        let res = Reflect.get(target, key, receiver) //  这二者是等价的 target[key]\n        // 之所以使用 reflect 是因为我们在使用 reflect 的时候会给我们一个返回值，告诉我们处理成功还是失败\n\n        if (isReadonly) { // 如果对象是一个仅读的属性，那就以意味着这个对象不可能被更改，不可能更新视图，不需要增添依赖收集\n            return res;\n        }\n        if (shallow) {\n            return res; // 如果是浅的说明不需要递归代理了\n        }\n        if (isObject(res)) { // 如果是对象 就递归代理，但是不是一开始就代理，是在用到这个对象的时候才进行代理的\n            // target[key];  懒代理，当取值的时候才去进行代理,而不是一上来全部递归，性能提升了很多\n            return isReadonly ? readonly(res) : reactive(res)\n        }\n        return res;\n    }\n}\nexport const mutableHandlers = { // 核心进行劫持的方法  处理get和set的逻辑\n    get,\n    set\n}\nexport const shallowReactiveHandlers = {\n    get: shallowGet,\n    set\n}\nexport const readonlyHandlers = extend({\n    get: readonlyGet,\n}, readonlySet)\nexport const shallowReadonlyHandlers = extend({\n    get: shallowReadonlyGet,\n}, readonlySet)\n","// 根据不同的参数实现不同的功能\nimport { isObject } from \"@vue/shared\"\nimport { mutableHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers } from \"./baseHandlers\"\n\n// 1.proxy 是一个es6的api，兼容性差，我们先来看一下这个 api 是怎么使用的\n// http://js.jirengu.com/juyim/3/edit?js,console,output\n\n// 给每个对象增加一个缓存区，防止对象被重复代理\n// 之所以使用 WeakMap,它有一个能力叫弱“引用”\n// map\"强引用“,它的key是可以用对象的,所以不会进入垃圾回收机制，会导致内存泄露\n// weakMap中的key只能是对象，如果引用的key 被置为 null weakmap 会自行自动回收\n// 用了 webmap 我们就不需要去手动的管理这些内存问题\nconst reactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\n\n// 函数科里化：这四个 api 都是使用 proxy 包装一下，区别只是是否仅读，是否浅层代理\nexport function reactive(target:object){ // mutableHandlers\n    return createReactiveObject(target,mutableHandlers,reactiveMap);\n}\nexport function shallowReactive(target:object){ // shallowReactiveHandlers\n    return createReactiveObject(target,shallowReactiveHandlers,shallowReactiveMap)\n}\nexport function readonly(target:object){ // readonlyHandlers\n    return createReactiveObject(target,readonlyHandlers,readonlyMap)\n}\nexport function shallowReadonly(target:object){ // shallowReadonlyHandlers\n    return createReactiveObject(target,shallowReadonlyHandlers,shallowReadonlyMap)\n}\n\n\n/**\n * @description 创建响应式对象 以上四个方法最终用的都是这一个方法，这个方法会根据参数的不同 来进行不同的处理,我们用这个方法来抹平差异\n * @param {Object} target 需要被代理的目标对象\n * @param {Function} baseHandlers 针对每种方式对应的不同处理函数\n * @param proxyMap\n */\nexport function createReactiveObject(target,baseHandlers,proxyMap) {\n    // 和 vue2 一样要看一下目标是不是对象,不是对象直接返回，无需代理\n    if(!isObject(target)){\n        return target\n    }\n    // 创建代理对象返回， let obj = {} reactive(obj)   readonly(obj) 做缓存 不要重复代理\n    // const proxyMap  = isReadonly ? readonlyMap : reactiveMap\n    const existsProxy = proxyMap.get(target);\n    // 如果已经代理过了，直接返回\n    if(existsProxy){\n        return existsProxy\n    }\n    // 创建代理对象\n    const proxy = new Proxy(target,baseHandlers);\n    proxyMap.set(target,proxy); // 缓存起来，避免重复代理 reactive(reactive({}))\n    return proxy\n}\n","import { hasChanged, isArray, isObject } from \"@vue/shared/src\";\nimport { track, trigger } from \"./effect\";\nimport { reactive } from \"./reactive\";\n\n\nexport function ref(value) {\n    return createRef(value);\n}\n\nexport function shallowRef(value) {\n    return createRef(value, true);\n}\nconst convert = val => isObject(val) ? reactive(val) : val;\n\nclass RefImpl {\n    private _value;\n    constructor(private rawValue, public isShallow) {\n        this._value = isShallow ? rawValue : convert(rawValue) // this._value 就是一个私有属性 \n    }\n    // 这两个方法 会被转化成defineProperty\n    get value() {\n        track(this, 'get', 'value')\n        return this._value;\n    }\n    set value(newValue) {\n        if (hasChanged(newValue, this.rawValue)) {\n            this.rawValue = newValue; // 说明属性变化 需要更新\n            this._value = this.isShallow ? newValue : convert(newValue)\n            trigger(this, 'value', newValue, 'set');\n        }\n\n    }\n}\nfunction createRef(value, isShallow = false) {\n    return new RefImpl(value, isShallow)\n\n}\nclass ObjectRefImpl{ // vue2 proxy 是一样的\n    constructor(public target,public key){}\n    get value(){\n        return this.target[this.key];\n    }\n    set value(newValue){\n        this.target[this.key] = newValue;\n    }\n}\n\n// promisefy\n// promisifyAll\nexport function toRefs(object){\n    // 对象的浅拷贝 \n    const ret = isArray(object)? new Array(object.length) : {};\n    for(let key in object){\n        ret[key] = toRef(object,key);\n    }\n    return ret;\n}\n\n\nexport function toRef(target,key){ // 就是取出某个属性变成ref\n    return new ObjectRefImpl(target,key)\n}\n\n\n// 模板渲染的时候 会去判断是不是ref 如果是ref  就直接.value"],"names":[],"mappings":"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"}